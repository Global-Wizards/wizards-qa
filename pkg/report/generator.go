package report

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/Global-Wizards/wizards-qa/pkg/maestro"
)

// Generator generates test reports from Maestro results
type Generator struct {
	Format             string // markdown, json, junit
	OutputDir          string
	IncludeScreenshots bool
	IncludeVideos      bool
}

// NewGenerator creates a new report generator
func NewGenerator(format, outputDir string, includeScreenshots, includeVideos bool) *Generator {
	return &Generator{
		Format:             format,
		OutputDir:          outputDir,
		IncludeScreenshots: includeScreenshots,
		IncludeVideos:      includeVideos,
	}
}

// Generate creates a test report from results
func (g *Generator) Generate(results *maestro.TestResults, gameName string) (string, error) {
	// Ensure output directory exists
	if err := os.MkdirAll(g.OutputDir, 0755); err != nil {
		return "", fmt.Errorf("failed to create output directory: %w", err)
	}

	// Generate report based on format
	switch g.Format {
	case "markdown":
		return g.generateMarkdown(results, gameName)
	case "json":
		return g.generateJSON(results, gameName)
	case "junit":
		return g.generateJUnit(results, gameName)
	default:
		return "", fmt.Errorf("unsupported format: %s", g.Format)
	}
}

// generateMarkdown creates a markdown test report
func (g *Generator) generateMarkdown(results *maestro.TestResults, gameName string) (string, error) {
	timestamp := time.Now().Format("2006-01-02-150405")
	filename := fmt.Sprintf("%s-report-%s.md", sanitizeFilename(gameName), timestamp)
	path := filepath.Join(g.OutputDir, filename)

	var md strings.Builder

	// Header
	md.WriteString(fmt.Sprintf("# Test Report - %s\n\n", gameName))
	md.WriteString(fmt.Sprintf("**Date:** %s  \n", results.StartTime.Format("2006-01-02 15:04:05")))
	md.WriteString(fmt.Sprintf("**Duration:** %s  \n", results.Duration.Round(time.Millisecond)))
	md.WriteString(fmt.Sprintf("**Status:** %s  \n\n", getStatusEmoji(results)))

	// Summary
	md.WriteString("## Summary\n\n")
	md.WriteString(fmt.Sprintf("- **Total Tests:** %d\n", results.Total))
	md.WriteString(fmt.Sprintf("- **Passed:** âœ… %d\n", results.Passed))
	md.WriteString(fmt.Sprintf("- **Failed:** âŒ %d\n", results.Failed))
	md.WriteString(fmt.Sprintf("- **Timeout:** â±ï¸  %d\n", results.Timeout))
	md.WriteString(fmt.Sprintf("- **Success Rate:** %.1f%%\n\n", results.SuccessRate()))

	// Test Results
	md.WriteString("## Test Results\n\n")

	for i, result := range results.Flows {
		md.WriteString(fmt.Sprintf("### %d. %s\n\n", i+1, result.FlowName))
		md.WriteString(fmt.Sprintf("- **Status:** %s %s\n", getStatusIcon(result.Status), result.Status))
		md.WriteString(fmt.Sprintf("- **Duration:** %s\n", result.Duration.Round(time.Millisecond)))

		if result.Error != "" {
			md.WriteString(fmt.Sprintf("- **Error:** %s\n", result.Error))
		}

		if result.Steps > 0 {
			md.WriteString(fmt.Sprintf("- **Steps:** %d\n", result.Steps))
		}

		md.WriteString("\n")

		// Include stdout if there are errors
		if result.Status != maestro.StatusPassed && result.Stdout != "" {
			md.WriteString("**Output:**\n\n")
			md.WriteString("```\n")
			md.WriteString(result.Stdout)
			md.WriteString("\n```\n\n")
		}
	}

	// Failed Tests Detail
	if results.Failed > 0 || results.Timeout > 0 {
		md.WriteString("## Failed Tests\n\n")
		for _, result := range results.Flows {
			if result.Status != maestro.StatusPassed {
				md.WriteString(fmt.Sprintf("### %s\n\n", result.FlowName))
				md.WriteString(fmt.Sprintf("- **Status:** %s\n", result.Status))
				md.WriteString(fmt.Sprintf("- **Error:** %s\n", result.Error))

				if result.Stderr != "" {
					md.WriteString("\n**Error Output:**\n\n")
					md.WriteString("```\n")
					md.WriteString(result.Stderr)
					md.WriteString("\n```\n\n")
				}
			}
		}
	}

	// Recommendations
	md.WriteString("## Recommendations\n\n")
	if results.SuccessRate() == 100 {
		md.WriteString("âœ… All tests passed! The game is working as expected.\n\n")
	} else if results.SuccessRate() >= 80 {
		md.WriteString("âš ï¸  Most tests passed, but some issues were found. Review failed tests above.\n\n")
	} else if results.SuccessRate() >= 50 {
		md.WriteString("âš ï¸  Significant issues detected. Multiple test failures need attention.\n\n")
	} else {
		md.WriteString("âŒ Critical issues detected. Most tests are failing. Immediate action required.\n\n")
	}

	// Footer
	md.WriteString("---\n\n")
	md.WriteString("*Generated by Wizards QA* ğŸ§™â€â™‚ï¸\n")

	// Write to file
	if err := os.WriteFile(path, []byte(md.String()), 0644); err != nil {
		return "", fmt.Errorf("failed to write report: %w", err)
	}

	return path, nil
}

// generateJSON creates a JSON test report
func (g *Generator) generateJSON(results *maestro.TestResults, gameName string) (string, error) {
	// TODO: Implement JSON report generation
	return "", fmt.Errorf("JSON format not yet implemented")
}

// generateJUnit creates a JUnit XML test report
func (g *Generator) generateJUnit(results *maestro.TestResults, gameName string) (string, error) {
	// TODO: Implement JUnit format generation
	return "", fmt.Errorf("JUnit format not yet implemented")
}

// getStatusEmoji returns an emoji for overall test results
func getStatusEmoji(results *maestro.TestResults) string {
	if results.Passed == results.Total {
		return "âœ… All tests passed"
	}
	if results.Failed > 0 || results.Timeout > 0 {
		return fmt.Sprintf("âŒ %d/%d tests failed", results.Failed+results.Timeout, results.Total)
	}
	return "âš ï¸  Mixed results"
}

// getStatusIcon returns an icon for a test status
func getStatusIcon(status maestro.Status) string {
	switch status {
	case maestro.StatusPassed:
		return "âœ…"
	case maestro.StatusFailed:
		return "âŒ"
	case maestro.StatusTimeout:
		return "â±ï¸"
	case maestro.StatusError:
		return "âš ï¸"
	default:
		return "â“"
	}
}

// sanitizeFilename removes unsafe characters from filenames
func sanitizeFilename(name string) string {
	unsafe := []string{"/", "\\", ":", "*", "?", "\"", "<", ">", "|", " "}
	safe := name
	for _, char := range unsafe {
		safe = strings.ReplaceAll(safe, char, "-")
	}
	return safe
}
