package report

import (
	"encoding/json"
	"fmt"
	"html"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/Global-Wizards/wizards-qa/pkg/maestro"
	"github.com/Global-Wizards/wizards-qa/pkg/util"
)

// Generator generates test reports from Maestro results
type Generator struct {
	Format             string // markdown, json, junit
	OutputDir          string
	IncludeScreenshots bool
	IncludeVideos      bool
}

// NewGenerator creates a new report generator
func NewGenerator(format, outputDir string, includeScreenshots, includeVideos bool) *Generator {
	return &Generator{
		Format:             format,
		OutputDir:          outputDir,
		IncludeScreenshots: includeScreenshots,
		IncludeVideos:      includeVideos,
	}
}

// Generate creates a test report from results
func (g *Generator) Generate(results *maestro.TestResults, gameName string) (string, error) {
	// Ensure output directory exists
	if err := os.MkdirAll(g.OutputDir, 0755); err != nil {
		return "", fmt.Errorf("failed to create output directory: %w", err)
	}

	// Generate report based on format
	switch g.Format {
	case "markdown":
		return g.generateMarkdown(results, gameName)
	case "json":
		return g.generateJSON(results, gameName)
	case "junit":
		return g.generateJUnit(results, gameName)
	default:
		return "", fmt.Errorf("unsupported format: %s", g.Format)
	}
}

// generateMarkdown creates a markdown test report
func (g *Generator) generateMarkdown(results *maestro.TestResults, gameName string) (string, error) {
	timestamp := time.Now().Format("2006-01-02-150405")
	filename := fmt.Sprintf("%s-report-%s.md", util.SanitizeFilename(gameName), timestamp)
	path := filepath.Join(g.OutputDir, filename)

	var md strings.Builder

	// Header
	md.WriteString(fmt.Sprintf("# Test Report - %s\n\n", gameName))
	md.WriteString(fmt.Sprintf("**Date:** %s  \n", results.StartTime.Format("2006-01-02 15:04:05")))
	md.WriteString(fmt.Sprintf("**Duration:** %s  \n", results.Duration.Round(time.Millisecond)))
	md.WriteString(fmt.Sprintf("**Status:** %s  \n\n", getStatusEmoji(results)))

	// Summary
	md.WriteString("## Summary\n\n")
	md.WriteString(fmt.Sprintf("- **Total Tests:** %d\n", results.Total))
	md.WriteString(fmt.Sprintf("- **Passed:** ‚úÖ %d\n", results.Passed))
	md.WriteString(fmt.Sprintf("- **Failed:** ‚ùå %d\n", results.Failed))
	md.WriteString(fmt.Sprintf("- **Timeout:** ‚è±Ô∏è  %d\n", results.Timeout))
	md.WriteString(fmt.Sprintf("- **Success Rate:** %.1f%%\n\n", results.SuccessRate()))

	// Test Results
	md.WriteString("## Test Results\n\n")

	for i, result := range results.Flows {
		md.WriteString(fmt.Sprintf("### %d. %s\n\n", i+1, result.FlowName))
		md.WriteString(fmt.Sprintf("- **Status:** %s %s\n", getStatusIcon(result.Status), result.Status))
		md.WriteString(fmt.Sprintf("- **Duration:** %s\n", result.Duration.Round(time.Millisecond)))

		if result.Error != "" {
			md.WriteString(fmt.Sprintf("- **Error:** %s\n", result.Error))
		}

		if result.Steps > 0 {
			md.WriteString(fmt.Sprintf("- **Steps:** %d\n", result.Steps))
		}

		md.WriteString("\n")

		// Include stdout if there are errors
		if result.Status != maestro.StatusPassed && result.Stdout != "" {
			md.WriteString("**Output:**\n\n")
			md.WriteString("```\n")
			md.WriteString(result.Stdout)
			md.WriteString("\n```\n\n")
		}
	}

	// Failed Tests Detail
	if results.Failed > 0 || results.Timeout > 0 {
		md.WriteString("## Failed Tests\n\n")
		for _, result := range results.Flows {
			if result.Status != maestro.StatusPassed {
				md.WriteString(fmt.Sprintf("### %s\n\n", result.FlowName))
				md.WriteString(fmt.Sprintf("- **Status:** %s\n", result.Status))
				md.WriteString(fmt.Sprintf("- **Error:** %s\n", result.Error))

				if result.Stderr != "" {
					md.WriteString("\n**Error Output:**\n\n")
					md.WriteString("```\n")
					md.WriteString(result.Stderr)
					md.WriteString("\n```\n\n")
				}
			}
		}
	}

	// Recommendations
	md.WriteString("## Recommendations\n\n")
	if results.SuccessRate() == 100 {
		md.WriteString("‚úÖ All tests passed! The game is working as expected.\n\n")
	} else if results.SuccessRate() >= 80 {
		md.WriteString("‚ö†Ô∏è  Most tests passed, but some issues were found. Review failed tests above.\n\n")
	} else if results.SuccessRate() >= 50 {
		md.WriteString("‚ö†Ô∏è  Significant issues detected. Multiple test failures need attention.\n\n")
	} else {
		md.WriteString("‚ùå Critical issues detected. Most tests are failing. Immediate action required.\n\n")
	}

	// Footer
	md.WriteString("---\n\n")
	md.WriteString("*Generated by Wizards QA* üßô‚Äç‚ôÇÔ∏è\n")

	// Write to file
	if err := os.WriteFile(path, []byte(md.String()), 0644); err != nil {
		return "", fmt.Errorf("failed to write report: %w", err)
	}

	return path, nil
}

// generateJSON creates a JSON test report
func (g *Generator) generateJSON(results *maestro.TestResults, gameName string) (string, error) {
	timestamp := time.Now().Format("2006-01-02-150405")
	filename := fmt.Sprintf("%s-report-%s.json", util.SanitizeFilename(gameName), timestamp)
	path := filepath.Join(g.OutputDir, filename)

	// Create JSON structure
	report := map[string]interface{}{
		"game":      gameName,
		"timestamp": results.StartTime.Format(time.RFC3339),
		"duration":  results.Duration.Milliseconds(),
		"summary": map[string]interface{}{
			"total":       results.Total,
			"passed":      results.Passed,
			"failed":      results.Failed,
			"timeout":     results.Timeout,
			"successRate": results.SuccessRate(),
		},
		"flows": []map[string]interface{}{},
	}

	// Add flow results
	flows := []map[string]interface{}{}
	for _, result := range results.Flows {
		flow := map[string]interface{}{
			"name":     result.FlowName,
			"path":     result.FlowPath,
			"status":   string(result.Status),
			"duration": result.Duration.Milliseconds(),
		}
		
		if result.Error != "" {
			flow["error"] = result.Error
		}
		if result.Steps > 0 {
			flow["steps"] = result.Steps
		}
		
		flows = append(flows, flow)
	}
	report["flows"] = flows

	// Marshal to JSON
	data, err := json.MarshalIndent(report, "", "  ")
	if err != nil {
		return "", fmt.Errorf("failed to marshal JSON: %w", err)
	}

	// Write to file
	if err := os.WriteFile(path, data, 0644); err != nil {
		return "", fmt.Errorf("failed to write report: %w", err)
	}

	return path, nil
}

// generateJUnit creates a JUnit XML test report
func (g *Generator) generateJUnit(results *maestro.TestResults, gameName string) (string, error) {
	timestamp := time.Now().Format("2006-01-02-150405")
	filename := fmt.Sprintf("%s-report-%s.xml", util.SanitizeFilename(gameName), timestamp)
	path := filepath.Join(g.OutputDir, filename)

	var xml strings.Builder
	
	// XML header
	xml.WriteString("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n")
	
	// Testsuite
	xml.WriteString(fmt.Sprintf("<testsuite name=\"%s\" tests=\"%d\" failures=\"%d\" errors=\"%d\" time=\"%.3f\" timestamp=\"%s\">\n",
		gameName,
		results.Total,
		results.Failed,
		results.Timeout,
		results.Duration.Seconds(),
		results.StartTime.Format(time.RFC3339),
	))

	// Test cases
	for _, result := range results.Flows {
		xml.WriteString(fmt.Sprintf("  <testcase name=\"%s\" classname=\"%s\" time=\"%.3f\"",
			result.FlowName,
			gameName,
			result.Duration.Seconds(),
		))

		if result.Status == maestro.StatusPassed {
			xml.WriteString(" />\n")
		} else {
			xml.WriteString(">\n")
			
			if result.Status == maestro.StatusFailed {
				xml.WriteString(fmt.Sprintf("    <failure message=\"%s\">%s</failure>\n",
					html.EscapeString(result.Error),
					html.EscapeString(result.Stderr),
				))
			} else if result.Status == maestro.StatusTimeout {
				xml.WriteString(fmt.Sprintf("    <error message=\"Test timeout\" type=\"timeout\">%s</error>\n",
					html.EscapeString(result.Error),
				))
			}
			
			xml.WriteString("  </testcase>\n")
		}
	}

	xml.WriteString("</testsuite>\n")

	// Write to file
	if err := os.WriteFile(path, []byte(xml.String()), 0644); err != nil {
		return "", fmt.Errorf("failed to write report: %w", err)
	}

	return path, nil
}

// getStatusEmoji returns an emoji for overall test results
func getStatusEmoji(results *maestro.TestResults) string {
	if results.Passed == results.Total {
		return "‚úÖ All tests passed"
	}
	if results.Failed > 0 || results.Timeout > 0 {
		return fmt.Sprintf("‚ùå %d/%d tests failed", results.Failed+results.Timeout, results.Total)
	}
	return "‚ö†Ô∏è  Mixed results"
}

// getStatusIcon returns an icon for a test status
func getStatusIcon(status maestro.Status) string {
	switch status {
	case maestro.StatusPassed:
		return "‚úÖ"
	case maestro.StatusFailed:
		return "‚ùå"
	case maestro.StatusTimeout:
		return "‚è±Ô∏è"
	case maestro.StatusError:
		return "‚ö†Ô∏è"
	default:
		return "‚ùì"
	}
}

