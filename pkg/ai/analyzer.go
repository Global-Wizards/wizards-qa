package ai

import (
	"fmt"
	"os"
	"strings"
)

// Analyzer analyzes games and generates test scenarios
type Analyzer struct {
	Client Client
}

// NewAnalyzer creates a new game analyzer
func NewAnalyzer(client Client) *Analyzer {
	return &Analyzer{
		Client: client,
	}
}

// NewAnalyzerFromConfig creates an analyzer from configuration
func NewAnalyzerFromConfig(provider, apiKey, model string, temperature float64, maxTokens int) (*Analyzer, error) {
	var client Client

	switch provider {
	case "anthropic", "claude":
		client = NewClaudeClient(apiKey, model, temperature, maxTokens)
	case "google", "gemini":
		client = NewGeminiClient(apiKey, model, temperature, maxTokens)
	default:
		return nil, fmt.Errorf("unsupported AI provider: %s (use 'anthropic' or 'google')", provider)
	}

	return &Analyzer{Client: client}, nil
}

// AnalyzeGame analyzes a game from specification and URL
func (a *Analyzer) AnalyzeGame(specPath, gameURL string) (*AnalysisResult, error) {
	// Read game specification
	specContent, err := os.ReadFile(specPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read spec file: %w", err)
	}

	// Build prompt
	prompt := fillTemplate(GameAnalysisPrompt.Template, map[string]string{
		"spec": string(specContent),
		"url":  gameURL,
	})

	// Call AI
	result, err := a.Client.Analyze(prompt, map[string]interface{}{
		"spec": string(specContent),
		"url":  gameURL,
	})
	if err != nil {
		return nil, fmt.Errorf("analysis failed: %w", err)
	}

	return result, nil
}

// GenerateScenarios generates test scenarios from game analysis
func (a *Analyzer) GenerateScenarios(analysis *AnalysisResult) ([]TestScenario, error) {
	// Convert analysis to string for context
	analysisStr := a.analysisToString(analysis)

	// Build prompt
	prompt := fillTemplate(ScenarioGenerationPrompt.Template, map[string]string{
		"analysis": analysisStr,
	})

	// Call AI
	response, err := a.Client.Generate(prompt, map[string]interface{}{
		"analysis": analysisStr,
	})
	if err != nil {
		return nil, fmt.Errorf("scenario generation failed: %w", err)
	}

	// Parse response as JSON array of scenarios
	// For now, return raw response wrapped in a scenario
	// TODO: Implement proper JSON parsing
	scenarios := []TestScenario{
		{
			Name:        "AI Generated Scenarios",
			Description: "Scenarios generated by AI",
			Type:        "mixed",
			Priority:    "high",
			Steps: []Step{
				{
					Action:   "raw",
					Target:   "response",
					Expected: response,
				},
			},
		},
	}

	return scenarios, nil
}

// GenerateFlows generates Maestro flows from test scenarios
func (a *Analyzer) GenerateFlows(scenarios []TestScenario) ([]*MaestroFlow, error) {
	// Convert scenarios to string
	scenariosStr := a.scenariosToString(scenarios)

	// Build prompt
	prompt := fillTemplate(FlowGenerationPrompt.Template, map[string]string{
		"scenarios": scenariosStr,
	})

	// Call AI
	response, err := a.Client.Generate(prompt, map[string]interface{}{
		"scenarios": scenariosStr,
	})
	if err != nil {
		return nil, fmt.Errorf("flow generation failed: %w", err)
	}

	// Parse YAML flows from response
	flows := a.parseFlowsFromResponse(response)

	return flows, nil
}

// analysisToString converts analysis to readable string
func (a *Analyzer) analysisToString(analysis *AnalysisResult) string {
	var sb strings.Builder

	if analysis.GameInfo.Name != "" {
		sb.WriteString(fmt.Sprintf("Game: %s\n", analysis.GameInfo.Name))
		sb.WriteString(fmt.Sprintf("Description: %s\n", analysis.GameInfo.Description))
		sb.WriteString(fmt.Sprintf("Genre: %s\n", analysis.GameInfo.Genre))
		sb.WriteString(fmt.Sprintf("Technology: %s\n\n", analysis.GameInfo.Technology))
	}

	if len(analysis.Mechanics) > 0 {
		sb.WriteString("Mechanics:\n")
		for _, m := range analysis.Mechanics {
			sb.WriteString(fmt.Sprintf("- %s: %s\n", m.Name, m.Description))
		}
		sb.WriteString("\n")
	}

	if len(analysis.UIElements) > 0 {
		sb.WriteString("UI Elements:\n")
		for _, ui := range analysis.UIElements {
			sb.WriteString(fmt.Sprintf("- %s (%s): %s\n", ui.Name, ui.Type, ui.Selector))
		}
		sb.WriteString("\n")
	}

	if len(analysis.UserFlows) > 0 {
		sb.WriteString("User Flows:\n")
		for _, flow := range analysis.UserFlows {
			sb.WriteString(fmt.Sprintf("- %s: %s\n", flow.Name, flow.Description))
		}
		sb.WriteString("\n")
	}

	if analysis.RawResponse != "" {
		sb.WriteString("Raw AI Response:\n")
		sb.WriteString(analysis.RawResponse)
		sb.WriteString("\n")
	}

	return sb.String()
}

// scenariosToString converts scenarios to readable string
func (a *Analyzer) scenariosToString(scenarios []TestScenario) string {
	var sb strings.Builder

	for i, scenario := range scenarios {
		sb.WriteString(fmt.Sprintf("%d. %s (%s)\n", i+1, scenario.Name, scenario.Type))
		sb.WriteString(fmt.Sprintf("   Description: %s\n", scenario.Description))
		sb.WriteString(fmt.Sprintf("   Priority: %s\n", scenario.Priority))
		
		if len(scenario.Steps) > 0 {
			sb.WriteString("   Steps:\n")
			for j, step := range scenario.Steps {
				sb.WriteString(fmt.Sprintf("   %d. %s %s", j+1, step.Action, step.Target))
				if step.Value != "" {
					sb.WriteString(fmt.Sprintf(": %s", step.Value))
				}
				sb.WriteString("\n")
			}
		}
		sb.WriteString("\n")
	}

	return sb.String()
}

// parseFlowsFromResponse extracts Maestro flows from AI response
func (a *Analyzer) parseFlowsFromResponse(response string) []*MaestroFlow {
	// For now, return the raw response wrapped in a flow
	// TODO: Implement proper YAML parsing from response
	flows := []*MaestroFlow{
		{
			Name: "AI Generated Flow",
			Commands: []map[string]interface{}{
				{
					"comment": response,
				},
			},
		},
	}

	return flows
}

// fillTemplate fills a template with variables
func fillTemplate(template string, vars map[string]string) string {
	result := template
	for key, value := range vars {
		placeholder := "{{" + key + "}}"
		result = strings.ReplaceAll(result, placeholder, value)
	}
	return result
}

// WriteFlowsToFiles writes Maestro flows to YAML files
func WriteFlowsToFiles(flows []*MaestroFlow, outputDir string) error {
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	for i, flow := range flows {
		filename := fmt.Sprintf("%02d-%s.yaml", i+1, sanitizeFilename(flow.Name))
		filepath := fmt.Sprintf("%s/%s", outputDir, filename)

		// Convert flow to YAML
		yamlContent := flowToYAML(flow)

		if err := os.WriteFile(filepath, []byte(yamlContent), 0644); err != nil {
			return fmt.Errorf("failed to write flow file: %w", err)
		}
	}

	return nil
}

// flowToYAML converts a MaestroFlow to YAML string
func flowToYAML(flow *MaestroFlow) string {
	var sb strings.Builder

	// Write metadata
	if flow.URL != "" {
		sb.WriteString(fmt.Sprintf("url: %s\n", flow.URL))
	}
	if flow.AppId != "" {
		sb.WriteString(fmt.Sprintf("appId: %s\n", flow.AppId))
	}
	if len(flow.Tags) > 0 {
		sb.WriteString("tags:\n")
		for _, tag := range flow.Tags {
			sb.WriteString(fmt.Sprintf("  - %s\n", tag))
		}
	}

	// Separator
	sb.WriteString("---\n")

	// Write commands
	for _, cmd := range flow.Commands {
		sb.WriteString(commandToYAML(cmd, 0))
	}

	return sb.String()
}

// commandToYAML converts a command map to YAML string
func commandToYAML(cmd map[string]interface{}, indent int) string {
	var sb strings.Builder
	prefix := strings.Repeat("  ", indent)

	for key, value := range cmd {
		switch v := value.(type) {
		case string:
			if key == "comment" {
				sb.WriteString(fmt.Sprintf("%s# %s\n", prefix, v))
			} else {
				sb.WriteString(fmt.Sprintf("%s- %s: %s\n", prefix, key, v))
			}
		case map[string]interface{}:
			sb.WriteString(fmt.Sprintf("%s- %s:\n", prefix, key))
			for subKey, subValue := range v {
				sb.WriteString(fmt.Sprintf("%s    %s: %v\n", prefix, subKey, subValue))
			}
		default:
			sb.WriteString(fmt.Sprintf("%s- %s: %v\n", prefix, key, v))
		}
	}

	return sb.String()
}

// sanitizeFilename removes unsafe characters
func sanitizeFilename(name string) string {
	unsafe := []string{"/", "\\", ":", "*", "?", "\"", "<", ">", "|", " "}
	safe := strings.ToLower(name)
	for _, char := range unsafe {
		safe = strings.ReplaceAll(safe, char, "-")
	}
	return safe
}
